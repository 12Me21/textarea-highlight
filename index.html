<!doctype html><meta charset=utf-8>
<meta name=viewport content="width=device-width, height=device-height, initial-scale=1">
<title>Editor with syntax highlighting</title>

<link rel=stylesheet href=style.css>
<link rel=stylesheet href=common.css>

<script src=hl-live.js></script>

<body class='Col'>
<textarea-container class='limit' tabindex=-1>
	<div id=$c tabindex=-1>
		<textarea-overlay id=$o></textarea-overlay>
		<textarea id=$i spellcheck=false><span>test</span></textarea>
	</div>
</textarea-container>
<div class='Row'>
	<div class='Col'>
		replaced nodes: <span id=$status></span><br>
		<table>
			<tr>
				<th> color <th> time
			<tr>
				<th style="background:gray"> gray <td> input delay
			<tr>
				<th style="background:lime"> lime <td> parsing
			<tr>
				<th style="background:#F60"> orange <td> rendering
			<tr>
				<th style="background:purple"> purple <td> layout
		</table>
		10ms divisions
	</div>
	<canvas height=200 width=500 id=$canvas style='width:max-content'></canvas>
</div>

<script>
	let input = $i
	let output = $o
	let canvas = $canvas
	
	"use strict"
	let c2d = canvas.getContext('2d')
	let cx
	let center = 100
	function reset_graph() {
		c2d.clearRect(10,0,500,200)
		c2d.fillStyle = 'black'
		c2d.fillRect(0,0,1,200)
		c2d.fillRect(0,100,9,1)
		for (let i=0; i<=50; i+=10) {
			c2d.fillRect(0,center - i*2 - 0.5,500,1)
			c2d.fillRect(0,center+1 + i*2 - 0.5,500,1)
		}
		cx=10
	}
	reset_graph()
	//c2d.fillRect(0,center,9,1)
	function graph_time(t0, after, before) {
		cx++
		if (cx>=500)
			reset_graph()
		c2d.fillStyle = 'white'
		c2d.fillRect(cx,center,1,1)
		for (let i=after.length-1; i>=1; i-=2) {
			let t = after[i]
			c2d.fillStyle = after[i-1]
			c2d.fillRect(cx,center,1,-(t-t0)*2)
		}
		for (let i=before.length-1; i>=1; i-=2) {
			let t = before[i]
			if (t) {
				c2d.fillStyle = before[i-1]
				c2d.fillRect(cx,center+1,1,-(t-t0)*2)
			}
		}
	}
	
	function update() {
		return render(input.value, output)
	}
	
	function get_last_indent(str, end) {
		let start
		for (start=end-1; start>=0 && str[start]!="\n"; start--)
			if (str[start]!=" " && str[start]!="\t")
				end = start
		return str.substring(start+1, end)
	}
	function capture_tab(input, state) {
		input.dataset.capture_tab = state ? "yes" : ""
	}
	function init(input, cb) {
		Object.assign(input, {
			onclick(e) { capture_tab(e.target, true) },
			onfocus(e) { capture_tab(e.target, false) },
			onblur(e) { capture_tab(e.target, false) },
			onkeydown(e) {
				if ('Tab'==e.key && !e.shiftKey && e.target.dataset.capture_tab) {
					cb && cb()
					e.preventDefault()
					document.execCommand('insertText', false, "\t")
				}
			},
			onbeforeinput(e) {
				cb && cb()
				capture_tab(e.target, true)
				if ('insertLineBreak'==e.inputType) {
					let indent = get_last_indent(e.target.value, e.target.selectionStart)
					if (indent) {
						e.preventDefault()
						document.execCommand('insertText', false, "\n"+indent)
					}
				}
			}
		})
	}
	
	let kdt
	init(input, ()=>{kdt=performance.now()})
	
	let lock = false
	let missed = true
	function a(tk) {
		missed = false
		let t0 = performance.now()
		let tp = update()
		let t1 = performance.now()
		void output.scrollHeight
		let t2 = performance.now()
		graph_time(t0, ['lime', tp, '#F60', t1, 'purple', t2], ['gray', tk])
	}
	
	input.addEventListener('input', e=>{
		if (lock) {
			missed = true
			return
		}
		lock = true
		a(kdt)
		kdt = null
		setTimeout(()=>{
			lock = false
			if (missed) {
				a(kdt)
				kdt = null
			}
		})
	}, {passive: true})
	
	fetch(location).then(x=>x.text()).then(x=>{
		input.value = x
		update()
	})
	
	update()
	
</script>
