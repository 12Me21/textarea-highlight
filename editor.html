<!doctype html><meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1, height=device-height">

<script src=hl2.js></script>

<style>
	scroll-outer {
		display: block;
		overflow-y: scroll;
		width: 700px;
		height: 500px;
	}
	
	textarea-container {
		display: block;
		position: relative;
		border: 3px solid black;
		background: black;
	}
	textarea-container > * {
		display: block;
		
		margin: 0;
		padding: 0;
		border: none;
		overflow-y: visible;
		width: 100%;
		
		white-space: pre-wrap;
		word-break: break-word;
		line-break: anywhere;
		
		font: 1em Cascadia Code, Fira Code, consolas, monospace;
		font-kerning: none;
		font-variant-ligatures: none;
		tab-size: 3; -moz-tab-size: 3;
	}
	textarea-container > .textarea {
		position: relative;
		z-index: 1;
		
		background: transparent;
		color: transparent;
		caret-color: white;
	}
	textarea-overlay {
		position: absolute;
		pointer-events: none;
		background: black;
		color: white;
	}
	.name { color: cyan; -webkit-text-stroke-width: .5px; }
	.comment { color: #0C0; }
	.commenttext { color: lime; }
	.tag { color: #0AF; }
	.doctype { color: silver; }
	.charref { color: magenta; }
	.key { color: orange; }
	.value { color: fuchsia; }
	.error { -webkit-text-stroke-width: 0.5px; -webkit-text-stroke-color: red; }
	.script { color: silver; }
	.rawtext { color: silver; }
	
	.prefix {color: lime;}
	.new {text-decoration: underline;}
	.suffix {color: blue;}
	
	@keyframes new {
		from {background: yellow;}
	}
	@keyframes new1 {
		from { -webkit-text-stroke-width: 2px; -webkit-text-stroke-color: currentColor;}
		to { -webkit-text-stroke-width: 2px; -webkit-text-stroke-color: transparent;}
	}
	@keyframes new2 {
		from { -webkit-text-stroke-width: 2px; -webkit-text-stroke-color: currentColor;}
		to { -webkit-text-stroke-width: 2px; -webkit-text-stroke-color: transparent;}
	}
	/*@keyframes new1 {
		from {text-decoration: underline white;}
		to {text-decoration: underline transparent; }
	}
	@keyframes new2 {
		from {text-decoration: underline white;}
		to {text-decoration: underline transparent; }
	}*/
	textarea-overlay > span[data-anim="true"] {
		animation: new1 1s;
	}
	textarea-overlay > span[data-anim="false"] {
		animation: new2 1s;
	}
	textarea-overlay > span[data-anim="new"] {
		animation: new 1s;
	}
</style>

<scroll-outer>
	<textarea-container id=$c>
		<textarea-overlay id=$o></textarea-overlay>
		<p class='textarea' contenteditable id=$i spellcheck=false>TEST&lt;div>HECK</p>
	</textarea-container>
</scroll-outer>

replaced nodes: <span id=$status></span>
<table>
	<tr> <th> parse/render: <td> <time id=$time1></time>ms
	<tr> <th> repaint: <td> <time id=$time2></time>ms
</table>

<script>
	let batch = (cb,w=0)=>e=>w++||requestAnimationFrame(_=>cb(e,w=0))
	
	x=performance.now()
	for (let i=0; i<1000; i++) {
		$o.textContent = ""
	}
	x-performance.now()
	
	let tm = document.createDocumentFragment()
	let lock=false
	
	let old_tokens=[], old_text=""
	function update(input) {
		let t = $i.innerText
		let [tokens, t1, t2, nlen, ind] = htmlp.parse(t, old_text, old_tokens)
		old_tokens = tokens
		old_text = t
		//console.log(prints(tokens))
		//$o.textContent = t
		//$o.textContent = ""
		let elem1 = $o.childNodes[t1+1]
		let elem2 = t2==null ? null : $o.childNodes[t2]
		$status.textContent = (t1+1)+".."+(t2==null ? "end" : t2-1)
		let prev
		for (let i=t1+1; i<nlen; i++) {
			if (elem1==elem2) {
				elem1 = document.createElement('span')
				$o.insertBefore(elem1, elem2)
				elem1.dataset.anim = 'new'
			} else {
				elem1.dataset.anim = elem1.dataset.anim=='false'
			}
			elem1.textContent = t.substr(ind, tokens[i].len)
			elem1.className = tokens[i].type
			elem1 = elem1.nextSibling
			ind += tokens[i].len
		}
		while (elem1!=elem2) {
			let prev = elem1
			elem1 = elem1.nextSibling
			prev.remove()
		}
		
		/*for (let x of tokens) {
			let p = document.createElement('span')
			if (x.type)
				p.className = x.type
			if (x.new==nw)
				p.className += ' new'
			p.textContent = t.substr(ind, x.len)
			ind += x.len
			$o.append(p)
		}*/
	}
	fetch(location).then(x=>x.text()).then(x=>{
		$i.textContent = x
		update()
	})
	//$i.textContent = document.documentElement.innerHTML
	update()
	
	function draw_time(elem, time) {
		elem.textContent = time.toFixed(1)
	}
	
	$i.addEventListener('input', batch(e=>{
		let t0 = performance.now()
		update($i.value)
		let t1 = performance.now()
		$o.scrollHeight
		let t2 = performance.now()
		draw_time($time1, t1-t0)
		draw_time($time2, t2-t1)
	}), {passive: true})
</script>

<dheck<span></span>
